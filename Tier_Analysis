import pandas as pd
import numpy as np
import time
import Tier_Pull
import datetime
pd.options.mode.chained_assignment = None
'''
'''


def represent_int(s):
    try:
        int(s)
        return True
    except ValueError:
        return False


def nan_column(df, name):
    df[name] = ''
    return df


def df_load():
    """
    Loading the file names to dataframes
    :return:
    """

    df = Tier_Pull.read_xlsx_file(r"\\newco.global\newcoroot\Global\EMEA\userdir$"
                                  r"\o_boom\Oliver\LC_Counterparty_Out.xlsx",
                                  "Performance")

    df_ranking = Tier_Pull.read_xlsx_file(r"\\newco.global\newcoroot\Global\EMEA\userdir$"
                                          r"\o_boom\Oliver\LC_Counterparty_Out.xlsx",
                                          "Tier Ranking")

    df_tier_change = Tier_Pull.read_xlsx_file(r"\\newco.global\newcoroot\Global\EMEA\userdir$"
                                              r"\o_boom\Oliver\LC_Counterparty_Out.xlsx",
                                              "Tier Changes")

    return df, df_ranking, df_tier_change


def view_or_copy(df, df2):
    if df.values.base is df2.values.base:
        print('A view')
    else:
        print('A copy')


def blank_df_creation():
    c = pd.DataFrame()
    d = pd.DataFrame()
    e = pd.DataFrame()
    f = pd.DataFrame()
    return c, d, e, f


def represent_str(s):
    try:
        str(s)
        return True
    except ValueError:
        return False


def empty_df(df):
    df.drop(df.index, inplace=True)
    return df


def date_conversion(df):
    """
    Converts df to datetime object
    :param df:
    :return: datetime object
    """
    df['TIME'] = pd.to_datetime(df.TIME, format='%Y-%m-%d %H:%M:%S.%f')
    return df


def date_order(df):
    """
    Orders the code by date
    :param df:
    :return: ordered df
    """
    df.sort_values(by='TIME', inplace=True)
    df = df.reset_index()
    return df


def days_on_tier(df, final_date):
    """
    Takes dataframe and finds the amount of days between
    a row and the next row after it
    :param df:
    :param final_date:
    :return: a list containing the amount of days
    """
    delta_l = []

    for index, row in df.iterrows():

        if index < len(df) - 1:
            d0 = df.iloc[index]['TIME']
            d1 = df.iloc[index + 1]['TIME']
            delta = d1 - d0
            delta_l.append(delta)
        else:
            d0 = df.iloc[index]['TIME']
            delta = final_date - d0
            delta_l.append(delta)

    return delta_l


def sweepable_assignment(df, LC_list):
    sweep_index = df.columns.get_loc("Sweep")

    for LC in LC_list:

        filter_LC = df.loc[df['LC_ACCOUNT'] == LC]
        LP_list = filter_LC['LP Floor ID'].unique()

        for LP in LP_list:

            filter_LP = filter_LC.loc[df['LP Floor ID'] == LP]

            for index, row in filter_LP.iterrows():

                if represent_int(row['Tier Code']):
                    df.iat[index, sweep_index] = 'Sweepable'

                elif represent_str(row['Tier Code']):
                    df.iat[index, sweep_index] = 'Non-Sweepable'
    return df


def days_assignment(df, df_sweep_non_sweep, LC_list, final_date):

    for LC in LC_list:

        filter_LC = df_sweep_non_sweep.loc[df['LC_ACCOUNT'] == LC]
        LP_list = filter_LC['LP Floor ID'].unique()

        for LP in LP_list:
            filter_LP = filter_LC.loc[filter_LC['LP Floor ID'] == LP]

            ordered_df = date_order(filter_LP)
            days_list = days_on_tier(ordered_df, final_date)

            ordered_df['Duration'] = days_list

            for index, row in ordered_df.iterrows():
                td = row['Duration']
                df.loc[(df['STATUS'] == 'Entitlement added') & (df['TIME'] == row['TIME'])
                       & (df['LP_ACCOUNT'] == row['LP_ACCOUNT']), 'Duration'] = td
    return df


def ranking_add(df, df_ranking):
    for index, row in df.iterrows():
        tier_of_interest = df_ranking.loc[df_ranking['LP FloorCode'] == (row['LP_TIER'])]
        rank = tier_of_interest['Ranking']
        df.loc[(df_ranking['LP FloorCode']) == (row['LP_TIER']), 'Ranking'] = rank
    return df

def main():
    start_time = time.clock()

    df, df_ranking, df_tier_change = df_load()

    LC_list = df_tier_change['LC_ACCOUNT'].unique()

    final_date = datetime.datetime(2018, 6, 27, 10, 21, 19, 438)

    df_tier_change = nan_column(df_tier_change, 'Sweep')
    df_tier_change = date_conversion(df_tier_change)
    #df_tier_change = nan_column(df_tier_change, 'Duration')

    df = sweepable_assignment(df_tier_change, LC_list)

    df_sweepable = df.loc[df['Sweep'] == 'Sweepable']
    df_non_sweepable = df.loc[df['Sweep'] == 'Non-Sweepable']


    days_assignment(df, df_sweepable, LC_list, final_date)
    days_assignment(df, df_non_sweepable, LC_list, final_date)
    df = ranking_add(df, df_ranking)
    write_location = pd.ExcelWriter(r"\\newco.global\newcoroot\Global\EMEA"
                                    r"\userdir$\o_boom\Oliver\LC_Counterparty_Up.xlsx")

    df.to_excel(write_location, 'Update')

    print(time.clock() - start_time, "seconds")


if __name__ == '__main__':
    main()
